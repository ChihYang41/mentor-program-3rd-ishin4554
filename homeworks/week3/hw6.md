## hw1：好多星星
問題是輸入一個數字，然後輸出一個 1 到該數字的連續星星的 Array。

這題的問題我會分成兩塊：
1. 每一個單元遞增的星星數。
2. 把每一個單元放進更大的 array 裡面。

落實到程式裡面是：
1. 利用一個 i 從 1 到 n 的 for loop 把星星數照著 i 的數字去 `'*'.repeat(i)` 星星數
2. 把重複的星星 string `.push()` 進 array 裡面。

## hw2：大小寫互換
問題是輸入一字串，字串中的大寫轉小寫、小寫轉大寫，如果不是英文字母無視。

這一題會這樣拆解：
1. 把所有大寫的部分轉成小寫
2. 所有小寫的部份轉成大寫

第一版的時候是這樣實踐：
1. 把 string 用 `.replace()` 用 regex 選取所有大寫的地方用 `.toLowerCase()` 的方式轉成小寫。

但過程中發現，如果我先用 `.replace()` 轉換後，第二次 `.replace()` 會把所有的字再轉換一次，所以這個過程一定要依序來處理才行，

所以把問題拆解改為：
1. 一個個字讀取
2. 如果字是小寫轉大寫
3. 如果字是大寫轉小寫

第二版的實踐方式是：
1. 用一個 for loop 從 0 開始到 string.length 一個個字讀取
2. 如果字 ASCILL => 'a' 且 ASCII <= 'z' 代表他屬於小寫，則用 `.toUpperCase()` 轉大寫，存進新的 newStr 裡面
3. 其他狀況（包含：大寫、其它字元），用 `.toUpperCase()` 他會自動無視，存進新的 newStr 裡面

## hw3：判斷質數
問題是輸入一數字 n，判斷他是不是質數，輸出是或不是。

這一題原本我是這樣拆解：
1. 這個數字如果不是 1 
2. 從 1 到該數字看看有幾個因數
3. 確認因數裡面是不是有除了自己跟 1 之外的因數

但稍微想一下有沒有比較快的解法，就是：
1. 從 2 開始看到該數 - 1 ，如果有任何其他因數就可以 break 回傳 false 了
2. 那這之外的狀況有：
    1. 他是 1，回傳 false
    2. 他是質數，回傳 true

用程式來實踐就是：
1. 用一個 for loop 讓 i 從 2 開始跑到 n-1 
2. 如果 n 除 i 的餘數等於 0，就回傳 false （loop 會自動 break）
3. 如果 loop 結束都沒有就判斷這個數字是不是 1，不是 1 回傳 true，是 1 回傳 fasle 

有趣的是，這個過程中，原本最後的 return 我是用三元判斷式寫：
`return n === 1 ? false : true` 

我覺得這樣比較直覺 XD 但 Eslint 修正成更簡潔我沒想過的寫法：
`return n !== 1`

## hw4：判斷迴文
輸入一個字串，判斷他是不是回文，輸出 true 或 false 

這題我寫的很開心 XDDDD 開啟了一行解的成就！

這題原本的拆解思路是：
1. 判斷 array 長度是不是偶數
2. 是偶數直接砍半：前半段正著讀取是不是等於後半段倒著讀取
3. 是奇數從正中間的數字切：前半段正著讀取是不是等於後半段倒著讀取

但覺得這樣硬幹是不是有點笨，真的有那麼複雜嗎？去耍個廢想了一下，突然發現，等等回文不就是正著讀跟反著讀都一樣嗎！
1. 直接回傳一個值看原本的 string 是不是等於倒著跑的 string 

但因為 `.reverse()` 要 array 才能用，所以：
1. string 先用 `.split()`拆開成 array 
2. 再用 `.reverse()` 倒播順序 
3. 最後 `.join()` 變回 string，比較跟原本 string 是不是一樣 

開心！

## hw5：大數加法
輸入兩個大數字串，輸出大數相加的成果。

這題的拆解思路是這樣，我先在紙筆上實作了一次加減，大概的過程就是，我一個個數字相加，大於 10 就會進位留剩下的個位數：
1. 把每個數字單存成 array 
2. 兩個 array 每一個值相加
3. array 大於 10 的在原本的欄位 -1 在下一個欄位 +1 
4. 如果欄位已經是在最前面，那就要塞一個 1 在前面
5. 轉回字串 

但過程中有幾個問題：
1. array 從 0 開始跑其實是從高位數開始跑，但其實我們相加是從後面開始
2. 發現相加的時候會出現很多 NaN，原來是，會有兩個大數字串的長度不同的時候
3. 雖然很笨但進位是不是真的只會 +1 

先快速的測試了第三個問題，用紙筆 99999+99999 發現最大數加起來也不會變成 20（好像也是）

所以就來解決第一跟二個問題，原本的思路是：有沒有可能讓讓 array 倒轉，後面 length 不足的地方自動補零，但後來覺得這樣想有點繞，因為最後還要在倒轉回去，才會是原本的數字，所以還是直覺的用：
1. 把兩大數相差的部分的 0 先建立好
2. 如果 a > b 就 a 前面補零
3. 否則就 b 前面補零，相同長度的狀況可以不考慮，因為就沒有 0 可以加

以上實踐成程式碼就是：
1. 補零：
    1. 存一個 reZero 的 string 裡面用 `.repeat()` 重複製造 a 長度 -  b 長度的絕對值 `Math.abs()` 的 0
    2. 如果 a > b 就 a 前面加上 reZero 
    3. 否則就 b 前面加上 reZero
2. a, b 相加：
    1. 把 a, b `.split("")` 成 array 
    2. 開一個新 array 用 for loop 把 a + b 的結果 `.push()` 進去 
3. 位數處理：
    1. 再用一個 for loop，從 array length -1 的位置倒回來（就是我們平常從小位數的方式）
    2. 判斷剛剛相加的結果有沒有大於 10 : 
        1. 如果大於 10 又如果這個數字不是最後一個，那就把大於 10 就把現在的數字 -10，下一個數字 +1 
        2. 是最後一個的話，就用 `.unshift()` 來塞 1 個 1 進 array 到最前面
4. 最後回傳 array 合併 `.join()` 成 string 的結果。

以上的過程有點硬幹，但暫時想了一早上，沒有想到更聰明簡潔的寫法，未來寫挑戰題的其他大數的時候可以想一下怎麼優化。